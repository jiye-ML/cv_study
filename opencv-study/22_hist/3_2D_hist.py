'''本节我们会学习    如何绘制 2D 直方图，    直方图反向投影'''import cv2import numpy as npfrom matplotlib import pyplot as pltfrom time import clockimport sys'''OpenCV 中的 2D 直方图使用函数 cv2.calcHist() 来计算直方图既简单又方便。如果要绘制颜色直方图的话，我们首先需要将图像的颜色空间从 BGR 转换到 HSV。（记住，计算一维直方图，要从 BGR 转换到 HSV）。计算 2D 直方图，函数的参数要做如下修改：    • channels=[0， 1] 因为我们需要同时处理 H 和 S 两个通道。    • bins=[180， 256]H 通道为 180， S 通道为 256。    • range=[0， 180， 0， 256]H 的取值范围在 0 到 180， S 的取值范围在 0 到 256。'''def hist_2d(img):    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)    hist = cv2.calcHist([hsv], [0, 1], None, [180, 256], [0, 180, 0, 256])    pass'''绘制 2D 直方图方法 1：使用 cv2.imshow() 我们得到结果是一个 180x256 的两维数组。所以我们可以使用函数 cv2.imshow() 来显示它。但是这是一个灰度图，除非我们知道不同颜色 H 通道的值，否则我们根本就不知道那到底代表什么颜色。方法 2：使用 Matplotlib() 我们还可以使用函数 matplotlib.pyplot.imshow()来绘制 2D 直方图，再搭配上不同的颜色图（color_map）。这样我们会对每个点所代表的数值大小有一个更直观的认识。但是跟前面的问题一样，你还是不知道那个数代表的颜色到底是什么。虽然如此，我还是更喜欢这个方法，它既简单又好用。注意： 在使用这个函数时，要记住设置插值参数为 nearest。方法 3： OpenCV 风格 在官方文档中有一个关于颜色直方图的例子。运行一下这个代码，你看到的颜色直方图也显示了对应的颜色。简单来说就是：输出结果是一副由颜色编码的直方图。效果非常好（虽然要添加很多代码）。在那个代码中，作者首先创建了一个 HSV 格式的颜色地图，然后把它转换成 BGR 格式。再将得到的直方图与颜色直方图相乘。作者还用了几步来去除小的孤立的的点，从而得到了一个好的直方图。我把对代码的分析留给你们了，自己去玩一下把。下边是对上边的图运行这段代码之后得到的结果：'''# plt绘制2d直方图def draw_2d_hist_use_plt(img):    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)    hist = cv2.calcHist([hsv], [0, 1], None, [180, 256], [0, 180, 0, 256])    plt.figure(1)    plt.subplot(121), plt.imshow(img, interpolation='nearest')    plt.subplot(122), plt.imshow(hist, interpolation='nearest')    plt.show()    pass# opencv 绘制 2d 直方图def draw_2d_hist_use_cv():    # 构建 hsv颜色地图    hsv_map = np.zeros((180, 256, 3), np.uint8)    h, s = np.indices(hsv_map.shape[:2])    hsv_map[:, :, 0] = h    hsv_map[:, :, 1] = s    hsv_map[:, :, 2] = 255    hsv_map = cv2.cvtColor(hsv_map, cv2.COLOR_HSV2BGR)    cv2.imshow('hsv_map', hsv_map)    cv2.namedWindow('hist', 0)    hist_scale = 10    def set_scale(val):        global hist_scale        hist_scale = val    cv2.createTrackbar('scale', 'hist', hist_scale, 32, set_scale)    try:        fn = sys.argv[1]    except:        fn = 0    cam = cv2.VideoCapture(fn)    while True:        flag, frame = cam.read()        cv2.imshow('camera', frame)        # 图像金字塔        # 通过图像金字塔降低分辨率，但不会对直方图有太大影响。        # 但这种低分辨率，可以很好抑制噪声，从而去除孤立的小点对直方图的影响。        small = cv2.pyrDown(frame)        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)        # 取 v 通道 (亮度) 的值。        dark = hsv[:, :, 2] < 32        hsv[dark] = 0        h = cv2.calcHist([hsv], [0, 1], None, [180, 256], [0, 180, 0, 256])        h = np.clip(h * 0.005 * hist_scale, 0, 1)        # h 从一维变成 3 维        vis = hsv_map * h[:, :, np.newaxis] / 255.0        cv2.imshow('hist', vis)        ch = 0xFF & cv2.waitKey(1)        if ch == 27:            break            pass        pass    pass    cv2.destroyAllWindows()    pass'''直方图反向投影原理它可以用来做图像分割，或者在图像中找寻我们感兴趣的部分。简单来说，它会输出与输入图像（待搜索）同样大小的图像，其中的每一个像素值代表了输入图像上对应点属于目标对象的概率。用更简单的话来解释，输出图像中像素值越高（越白）的点就越可能代表我们要搜索的目标（在输入图像所在的位置）。这是一个直观的解释。直方图投影经常与 camshift算法等一起使用。我们应该怎样来实现这个算法呢？首先我们要为一张包含我们要查找目标的图像创建直方图（在我们的示例中，我们要查找的是草地，其他的都不要）。我们要查找的对象要尽量占满这张图像（换句话说，这张图像上最好是有且仅有我们要查找的对象）。最好使用颜色直方图，因为一个物体的颜色要比它的灰度能更好的被用来进行图像分割与对象识别。接着我们再把这个颜色直方图投影到输入图像中寻找我们的目标，也就是找到输入图像中的每一个像素点的像素值在直方图中对应的概率，这样我们就得到一个概率图像，最后设置适当的阈值对概率图像进行二值化，就这么简单。'''# Numpy 中的算法def numpy_reverse_projection(img):    '''    首先，我们要创建两幅颜色直方图，目标图像的直方图（'M'），（待搜索）输入图像的直方图（'I'）。    计算比值： R = M / I 。反向投影 R，也就是根据 R 这个”调色板“创建一副新的图像，其中的每一个像素代表这个点就是目标的概率。    例如 B (x, y) = R [h (x, y) , s (x, y)]，其中 h 为点（x， y）处的 hue 值， s 为点（x， y）处的saturation 值。    最后加入再一个条件 B (x, y) = min [B (x, y) , 1]。        '''    # roi is the object or region of object we need to find    roi = np.copy(img)    hsv = cv2.cvtColor(roi, cv2.COLOR_BGR2HSV)    # target is the image we search in    target = np.copy(img)    hsv_target = cv2.cvtColor(target, cv2.COLOR_BGR2HSV)    # 直方图    M = cv2.calcHist([hsv], [0, 1], None, [180, 256], [0, 180, 0, 256])    I = cv2.calcHist([hsv_target], [0, 1], None, [180, 256], [0, 180, 0, 256])    # 计算比值： R = M / I ,每一个像素代表这个点就是目标的概率    R = M / I    h, s, v = cv2.split(hsv_target)    B = R[h.ravel(), s.ravel()]    B = np.minimum(B, 1)    B = B.reshape(hsv_target.shape[:2])    # 现在使用一个圆盘算子做卷积， B = D × B，其中 D 为卷积核。    disc = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))    B = cv2.filter2D(B, -1, disc)    B = np.uint8(B)    cv2.normalize(B, B, 0, 255, cv2.NORM_MINMAX)    # 现在输出图像中灰度值最大的地方就是我们要查找的目标的位置了。    # 如果我们要找的是一个区域，我们就可以使用一个阈值对图像进行二值化，这样就可以得到一个很好的结果了。    ret, thresh = cv2.threshold(B, 50, 255, 0)    pass# OpenCV 中的反向投影def cv_reverse_projection(img):    '''    OpenCV 提供的函数 cv2.calcBackProject() 可以用来做直方图反向投影。    它的参数与函数 cv2.calcHist 的参数基本相同。    其中的一个参数是我们要查找目标的直方图。同样再使用目标的直方图做反向投影之前我们应该先对其做归一化处理。    返回的结果是一个概率图像，我们再使用一个圆盘形卷积核对其做卷操作，最后使用阈值进行二值化。下面就是代码和结果：    '''    # roi is the object or region of object we need to find    roi = np.copy(img)    hsv = cv2.cvtColor(roi, cv2.COLOR_BGR2HSV)    # target is the image we search in    target = np.copy(img)    hsv_target = cv2.cvtColor(target, cv2.COLOR_BGR2HSV)    roi_hist = cv2.calcHist([hsv], [0, 1], None, [180, 256], [0, 180, 0, 256])    cv2.normalize(roi_hist, roi_hist, 0, 255, cv2.NORM_MINMAX)    dst = cv2.calcBackProject([hsv_target], [0, 1], roi_hist, [0, 180, 0, 255], 1)    ret, thresh = cv2.threshold(dst, 50, 255, 0)    #  使用 merge 变成 3 通道    thresh = cv2.merge((thresh, thresh, thresh))    res = cv2.bitwise_and(target, thresh)    res = np.hstack((target, thresh, res))    cv2.imwrite('res.jpg', res)    # 显示    cv2.imshow('1', res)    cv2.waitKey(0)    passif __name__ == '__main__':    img = cv2.imread('../data/plane.jpg')    cv_reverse_projection(img)    pass