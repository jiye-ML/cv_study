'''本小节我们要学习直方图均衡化的概念，以及如何使用它来改善图片的对比。'''import cv2import numpy as np'''原理想象一下如果一副图像中的大多是像素点的像素值都集中在一个像素值范围之内会怎样呢？例如，如果一幅图片整体很亮，那所有的像素值应该都会很高。但是一副高质量的图像的像素值分布应该很广泛。所以你应该把它的直方图做一个横向拉伸（如下图），这就是直方图均衡化要做的事情。通常情况下这种操作会改善图像的对比度。特点：即使我们的输入图片是一个比较暗的图片，经过直方图均衡化之后也能得到相同的结果。因此，直方图均衡化经常用来使所有的图片具有相同的亮度条件的参考工具。这在很多情况下都很有用。例如，脸部识别，在训练分类器前，训练集的所有图片都要先进行直方图均衡化从而使它们达到相同的亮度条件。'''# OpenCV 中的直方图均衡化函数为 cv2.equalizeHist()。这个函数的输入图片仅仅是一副灰度图像，输出结果是直方图均衡化之后的图像def equalize_hist(img):    '''    当直方图中的数据集中在某一个灰度值范围内时，直方图均衡化很有用。    但是如果像素的变化很大，而且占据的灰度范围非常广时，例如：既有很亮的像素点又有很暗的像素点时。    '''    equ = cv2.equalizeHist(img)    res = np.hstack((img, equ))    cv2.imshow('res.png', res)    cv2.waitKey()    pass'''CLAHE 有限对比适应性直方图均衡化我们在上边做的直方图均衡化会改变整个图像的对比度，但是在很多情况下，这样做的效果并不好。我们需要使用自适应的直方图均衡化。这种情况下，整幅图像会被分成很多小块，这些小块被称为“tiles”（在 OpenCV 中 tiles 的大小默认是 8x8），然后再对每一个小块分别进行直方图均衡化（跟前面类似）。所以在每一个的区域中，直方图会集中在某一个小的区域中（除非有噪声干扰）。如果有噪声的话，噪声会被放大。为了避免这种情况的出现要使用对比度限制。对于每个小块来说，如果直方图中的 bin 超过对比度的上限的话，就把其中的像素点均匀分散到其他 bins 中，然后在进行直方图均衡化。最后，为了去除每一个小块之间“人造的”（由于算法造成）边界，再使用双线性差值，对小块进行缝合。'''def clahe(img):    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))    cl = clahe.apply(img)    cv2.imwrite('clahe_2.jpg', cl)    passif __name__ == '__main__':    img = cv2.imread('../data/plane.jpg', 0)    clahe(img)    pass