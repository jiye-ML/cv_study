'''使用 GrabCut 算法进行交互式前景提取'''import cv2import numpy as npfrom matplotlib import pyplot as plt'''原理从用户的角度来看它到底是如何工作的呢？开始时用户需要用一个矩形将前景区域框住（前景区域应该完全被包括在矩形框内部）。然后算法进行迭代式分割直达达到最好结果。但是有时分割的结果不够理想，比如把前景当成了背景，或者把背景当成了前景。在这种情况下，就需要用户来进行修改了。用户只需要在不理想的部位画一笔（点一下鼠标）就可以了。画一笔就等于在告诉计算机：“嗨，老兄，你把这里弄反了，下次迭代的时候记得改过来呀！”。然后，在下一轮迭代的时候你就会得到一个更好的结果了''''''cv2.grabCut()* img - 输入图像* mask-掩模图像，用来确定哪些区域是背景，前景，可能是前景/背景等。可以设置为：cv2.GC_BGD,cv2.GC_FGD,cv2.GC_PR_BGD,cv2.GC_PR_FGD，或者直接输入 0,1,2,3 也行。* rect - 包含前景的矩形，格式为 (x,y,w,h)* bdgModel, fgdModel - 算法内部使用的数组. 你只需要创建两个大小为 (1,65)，数据类型为 np.float64 的数组。* iterCount - 算法的迭代次数* mode 可以设置为 cv2.GC_INIT_WITH_RECT 或 cv2.GC_INIT_WITH_MASK，也可以联合使用。这是用来确定我们进行修改的方式，矩形模式或者掩模模式。'''image = cv2.imread('../data/plane.jpg')mask = np.zeros(image.shape[:2], np.uint8)bgdModel = np.zeros((1, 65), np.float64)fgdModel = np.zeros((1, 65), np.float64)rect = (50, 50, 450, 290)# 函数的返回值是更新的 mask, bgdModel, fgdModelcv2.grabCut(image, mask, rect, bgdModel, fgdModel, 5, cv2.GC_INIT_WITH_RECT)# 在新的掩模图像中，所有的像素被分为四类：背景，前景，可能是背景/前景使用 4 个不同的标签标记# 然后我们来修改掩模图像，所有的 0 像素和 1 像素都被归为 0（例如背景），# 所有的 1 像素和 3 像素都被归为 1（前景）。mask2 = np.where((mask == 2) | (mask == 0), 0, 1).astype('uint8')image = image * mask2[:, :, np.newaxis]plt.imshow(image), plt.colorbar(), plt.show()#######################  下面就是所谓的交互式， 其中newmask是根据刚才显示的图，不对的地方的人工标注# newmask is the mask image I manually labellednewmask = cv2.imread('newmask.png',0)# whereever it is marked white (sure foreground), change mask=1# whereever it is marked black (sure background), change mask=0mask[newmask == 0] = 0mask[newmask == 255] = 1mask, bgdModel, fgdModel = cv2.grabCut(image,mask,None,bgdModel,fgdModel,5,cv2.GC_INIT_WITH_MASK)mask = np.where((mask==2)|(mask==0),0,1).astype('uint8')img = image*mask[:,:,np.newaxis]plt.imshow(img),plt.colorbar(),plt.show()