import cv2import numpy as np'''什么是轮廓轮廓可以简单认为成将连续的点（连着边界）连在一起的曲线，具有相同的颜色或者灰度。• 为了更加准确，要使用二值化图像。在寻找轮廓之前，要进行阈值化处理或者 Canny 边界检测。• 查找轮廓的函数会修改原始图像。• 要找的物体应该是白色而背景应该是黑色。''''''提取，绘制轮廓'''# 提取，绘制轮廓def contour(image):    '''    功能： 提取，绘制轮廓        函数一：cv2.findContours() [输入图像，轮廓检索模式，轮廓近似方法]    参数说明：轮廓检索模式: cv2.CHAIN_APPROX_NONE（记录所有点）、cv2.CHAIN_APPROX_SIMPLE（只记录关键点，如直线端点）    返回值： 图像，轮廓,（轮廓的）层析结构        函数2： cv2.drawContours() [原始图像, 轮廓, 轮廓的索引, 轮廓的颜色和厚度]    函数2说明: 可以被用来绘制轮廓。它可以根据你提供的边界点绘制任何形状。    '''    # 图像    imgray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)    # 阈值    ret, thresh = cv2.threshold(imgray, 127, 255, 0)    # 提取轮廓    # 第二个参数： 轮廓检索模式        # RETR_LIST: 在同一级组织轮廓，不区分父子关系        # RETR_EXTERNAL： 只返回最外面轮廓        # RETR_CCOMP： 在这种模式下会返回所有的轮廓并将轮廓分为两级组织结构。        # RETR_TREE： 这种模式下会返回所有轮廓，并且创建一个完整的组织结构列表。    # 返回值：        # 层级结构：父子轮廓区分 [Next， Previous，First_Child， Parent]。    image, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)    # 绘制轮廓， -1 表示绘制所有轮廓    image = cv2.drawContours(image, contours, -1, (0, 255, 0), 3)    cv2.imshow('image', image)    cv2.waitKey()    cv2.destroyAllWindows()    pass'''轮廓特征查找轮廓的不同特征，例如面积，周长，重心，边界框等。'''# 矩， 然后利用矩计算轮廓的质心，面积，周长。def moment_area_perimeter(image):    '''    功能： 矩， 然后利用矩计算轮廓的质心，面积，周长。    '''    imgray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)    ret, thresh = cv2.threshold(imgray, 127, 255, 0)    image, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)    cnt = contours[0]    # 获得矩    M = cv2.moments(cnt)    # 计算重心    cx = int(M['m10'] / M['m00'])    cy = int(M['m01'] / M['m00'])    # 计算轮廓面积    area = cv2.contourArea(cnt)    # 轮廓周长, 第二个参数指定对象的形状是闭合的（True），还是打开的（一条曲线）。    perimeter = cv2.arcLength(cnt, True)    pass'''轮廓近似'''# 将轮廓形状近似到另外一种由更少点组成的轮廓形状，新轮廓的点的数目由我们设定的准确度来决定def approx_contour(image):    '''    功能： 将轮廓形状近似到另外一种由更少点组成的轮廓形状，新轮廓的点的数目由我们设定的准确度来决定    说明： 使用的Douglas-Peucker算法，假设我们要在一幅图像中查找一个矩形，但是由于图像的种种原因，            我们不能得到一个完美的矩形，而是一个“坏形状”。现在你就可以使用这个函数来近似这个形状（）了。    参数： 这个函数的第二个参数叫epsilon，它是从原始轮廓到近似轮廓的最大距离。            它是一个准确度参数。选择一个好的 epsilon 对于得到满意结果非常重要。    '''    imgray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)    ret, thresh = cv2.threshold(imgray, 127, 255, 0)    image, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)    cnt = contours[0]    epsilon = 0.1 * cv2.arcLength(cnt, True)    # 【轮廓曲线，近似度，闭合？】    approx = cv2.approxPolyDP(cnt, epsilon, True)    pass'''凸包'''def convex_hull(image):    '''    函数 cv2.convexHull() 可以用来检测一个曲线是否具有凸性缺陷，并能纠正缺陷。    hull = cv2.convexHull(points[, hull[, clockwise[, returnPoints]]    参数：    • points 我们要传入的轮廓    • hull 输出，通常不需要    • clockwise 方向标志。True，顺时针方向。否则为逆时针方向。    • returnPoints 默认值为 True。返回凸包上点的坐标。如果设置为 False，就会返回与凸包点对应的轮廓上的点。    '''    imgray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)    ret, thresh = cv2.threshold(imgray, 127, 255, 0)    image, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)    cnt = contours[0]    # 获得凸包    hull = cv2.convexHull(cnt)    # 凸性检测    k = cv2.isContourConvex(cnt)    print(k)    pass'''轮廓的性质'''def contour_nature(image):    imgray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)    ret, thresh = cv2.threshold(imgray, 127, 255, 0)    image, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)    cnt = contours[0]    # 边界矩形的宽高比    x, y, w, h = cv2.boundingRect(cnt)    aspect_ratio = float(w) / h    # 轮廓面积与凸包面积的比。    area = cv2.contourArea(cnt)    hull = cv2.convexHull(cnt)    hull_area = cv2.contourArea(hull)    solidity = float(area) / hull_area    # 掩模和像素点: 获得构成对象的所有像素点    mask = np.zeros(imgray.shape, np.uint8)    # mask图上绘制轮廓    cv2.drawContours(mask, [cnt], 0, 255, -1)    # 获取轮廓内的所有像素点    pixelpoints = cv2.findNonZero(mask)    # 最大值和最小值及它们的位置    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(imgray, mask=mask)    # 平均颜色及平均灰度    mean_val = cv2.mean(imgray, mask=mask)    # 极点    leftmost = tuple(cnt[cnt[:, :, 0].argmin()][0])    rightmost = tuple(cnt[cnt[:, :, 0].argmax()][0])    topmost = tuple(cnt[cnt[:, :, 1].argmin()][0])    bottommost = tuple(cnt[cnt[:, :, 1].argmax()][0])    passif __name__ == '__main__':    image = cv2.imread('../data/opencv_logo.png')    contour_nature(image)    pass