import cv2'''两幅图像的混合'''def add_weight(src, dest):    '''    dst = α · img1 + β · img2 + γ    得加两幅图，一种混合或者透明的感觉。    '''    dst = cv2.addWeighted(src, 0.7, dest, 0.3, 0)    cv2.imshow('dst', dst)    cv2.waitKey()    cv2.destroyAllWindows()    pass'''按位运算'''# 将一幅图的贴到另一幅图的特定区域def bit_op(src, dest):    '''    说明： 这里包括的按位操作有： AND， OR， NOT， XOR 等。当我们提取图像的一部分，选择非矩形 ROI 时这些操作会很有用。    我想把 OpenCV 的标志放到另一幅图像上。如果我使用加法，颜色会改变，如果使用混合，会得到透明效果，但是我不想要透明。    如果他是矩形我可以象上一章那样使用 ROI。但是他不是矩形。但是我们可以通过下面的按位运算实现：    '''    # 得到区域大小    rows, cols, channels = dest.shape    # 提取原图中需要替换的区域    roi = src[0:rows, 0:cols]    # 创建掩码， cv2.threshold 需要处理灰度图    img2gray = cv2.cvtColor(dest, cv2.COLOR_BGR2GRAY)    # 保留 [175, 255]， 其他为0    ret, mask = cv2.threshold(img2gray, 175, 255, cv2.THRESH_BINARY)    mask_inv = cv2.bitwise_not(mask)    # 提出 src 的特定区域    src_bg = cv2.bitwise_and(roi, roi, mask=mask)    dest_bg = cv2.bitwise_and(dest, dest, mask=mask_inv)    # 得到需要显示的区域的像素    dst = cv2.add(src_bg, dest_bg)    src[0:rows, 0: cols] = dst    # 显示    cv2.imshow('res', src)    cv2.waitKey(0)    cv2.destroyAllWindows()    passif __name__ == '__main__':    src = cv2.imread("../data/dandelion2.jpg")    dest = cv2.imread("../data/opencv_logo.png")    bit_op(dest, src)    pass