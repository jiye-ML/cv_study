import cv2import numpy as npfrom matplotlib import pyplot as plt'''原理梯度简单来说就是求导。OpenCV 提供了三种不同的梯度滤波器: Sobel，Scharr 和 Laplacian。Sobel， Scharr 其实就是求一阶或二阶导数。 Scharr 是对 Sobel（使用小的卷积核求解求解梯度角度时）的优化。Laplacian 是求二阶导数。'''# 三种滤波器对同一幅图进行操作。检测边界def filter(image):    '''    功能： 三种滤波器对同一幅图进行操作。检测边界    提示： 使用 cv2.CV_64F的原因：        从黑到白的边界的导数是整数，从白到黑的边界点导数却是负数。如果原图像的深度是np.int8 时，所有的负值都会被截断变成 0，换句话说就是把把边界丢失掉。        所以如果这两种边界你都想检测到，最好的的办法就是将输出的数据类型设置的更高，比如 cv2.CV_16S， cv2.CV_64F 等。        取绝对值然后再把它转回到 cv2.CV_8U。    '''    # cv2.CV_64F 输出图像的深度（数据类型），可以使用-1, 与原图像保持一致 np.uint8    laplacian = cv2.Laplacian(image, cv2.CV_64F)    # 参数 1,0 为只在 x 方向求一阶导数，最大可以求 2 阶导数。    sobel_x = cv2.Sobel(image, cv2.CV_64F, 1, 0, ksize=5)    # 参数 0,1 为只在 y 方向求一阶导数，最大可以求 2 阶导数。    sobel_y = cv2.Sobel(image, cv2.CV_64F, 0, 1, ksize=5)    plt.figure(1)    plt.subplot(221), plt.imshow(image)    plt.subplot(222), plt.imshow(laplacian)    plt.subplot(223), plt.imshow(sobel_x)    plt.subplot(224), plt.imshow(sobel_y)    plt.show()    plt.close()    pass'''Canny 边缘检测'''def canny(image):    '''    说明： Canny 边缘检测是一种非常流行的边缘检测算法    步骤：        1. 噪声去除：利用高斯滤波器        2. 计算图像梯度：sobel算子计算x, y的一阶导数        3. 非极大值抑制：对每一个像素进行检查，看这个点的梯度是不是周围具有相同梯度方向的点中最大的。        4. 滞后阈值：             1. 梯度高于 maxVal 真的边界，            2. 低于 minVal 抛弃。            3. 介于两者，与某个被确定为真正的边界点相连，是边界点            '''    edges = cv2.Canny(image, 100, 200)    plt.figure(1)    plt.subplot(121)    plt.imshow(image)    plt.subplot(122)    plt.imshow(edges)    plt.show()    passif __name__ == '__main__':    image = cv2.imread('../data/opencv_logo.png')    canny(image)    pass