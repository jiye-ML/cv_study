'''图像窗口移动到密度最大的地方'''import cv2import numpy as np'''meanshift'''# 框向密度更大方向移动def mean_shift():    '''    功能： 捕捉刚开始采集到的目标， 向着该目标更密集的地方移动    说明： 需要刚开始窗口采集到的目标是可以变化的，如果刚开始采集墙面，那么没救了    '''    cap = cv2.VideoCapture(0)    # 第一帧数据    ret, frame = cap.read()    # 初始化窗口    r, h, c, w = 250, 90, 400, 125    track_window = (c, r, w, h)    # 设置 ROI    roi = frame[r:r+h, c:c+w]    hsv_roi = cv2.cvtColor(roi, cv2.COLOR_BGR2HSV)    # 避免低亮度造成的影响    mask = cv2.inRange(hsv_roi, np.array((0, 60, 32)), np.array((180, 255, 255)))    # 计算统计直方图    roi_hist = cv2.calcHist([hsv_roi], [0], mask, [180], [0, 180])    cv2.normalize(roi_hist, roi_hist, 0, 255, cv2.NORM_MINMAX)    # Setup the termination criteria, either 10 iteration or move by atleast 1 pt    term_crit = ( cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, 10, 1 )    while 1:        ret, frame = cap.read()        if ret == True:            hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)            # 执行 meanshift 算法时将目标对象反向投影到每一帧中去了            dst = cv2.calcBackProject([hsv], [0], roi_hist, [0, 180], 1)            ret, track_window = cv2.meanShift(dst, track_window, term_crit)            x, y, w, h = track_window            image2 = cv2.rectangle(frame, (x, y), (x + w, y + h), 255, 2)            cv2.imshow('image', image2)            k = cv2.waitKey(60) & 0xff            if k == 27:                break        pass    cv2.destroyAllWindows()    cap.release()    pass'''Camshift'''# 可以调整窗口大小def cam_shift():    cap = cv2.VideoCapture(0)    # 第一帧数据    ret, frame = cap.read()    # 初始化窗口    r, h, c, w = 250, 90, 400, 125    track_window = (c, r, w, h)    # 设置 ROI    roi = frame[r:r+h, c:c+w]    hsv_roi = cv2.cvtColor(roi, cv2.COLOR_BGR2HSV)    # 避免低亮度造成的影响    mask = cv2.inRange(hsv_roi, np.array((0, 60, 32)), np.array((180, 255, 255)))    # 计算统计直方图    roi_hist = cv2.calcHist([hsv_roi], [0], mask, [180], [0, 180])    cv2.normalize(roi_hist, roi_hist, 0, 255, cv2.NORM_MINMAX)    # Setup the termination criteria, either 10 iteration or move by atleast 1 pt    term_crit = ( cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, 10, 1 )    while 1:        ret, frame = cap.read()        if ret == True:            hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)            # 执行 meanshift 算法时将目标对象反向投影到每一帧中去了            dst = cv2.calcBackProject([hsv], [0], roi_hist, [0, 180], 1)            ret, track_window = cv2.meanShift(dst, track_window, term_crit)            # 画图            pts = cv2.boxPoints(ret)            pts = np.int0(pts)            image2 = cv2.polylines(frame, [pts], True, 255, 2)            cv2.imshow('image2', image2)            k = cv2.waitKey(60) & 0xff            if k == 27:                break        pass    cv2.destroyAllWindows()    cap.release()    passif __name__ == '__main__':    mean_shift()    pass